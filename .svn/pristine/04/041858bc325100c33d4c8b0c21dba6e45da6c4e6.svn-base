using DG.Tweening;
using Platform.Model.Battle;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Platform.Utils
{
    /// <summary>
    /// 牌面排序相关工具类
    /// </summary>
    class BattleAreaUtil
    {
        /// <summary>
        /// 获取麻将对应的牌值
        /// </summary>
        /// <param name="obj">麻将对象</param>
        /// <returns></returns>
        public static int GetMeshCardValue(GameObject obj)
        {
            var meshFilter = obj.GetComponent<MeshFilter>();
            var nameIndex = Array.IndexOf(GlobalData.MeshNames, meshFilter.sharedMesh.name);
            return GlobalData.CardValues[nameIndex];
        }

        /// <summary>
        /// 重排牌的位置
        /// </summary>
        public static void ResortCard(BattleAreaItem areaItem, bool isDoTween)
        {
            ResortHandGangGetCard(areaItem, isDoTween);
            ResortPutCard(areaItem);
        }

        /// <summary>
        /// 重排碰杠 手牌 摸到的牌位置
        /// </summary>
        public static void ResortHandGangGetCard(BattleAreaItem areaItem, bool isDoTween)
        {
            var battleProxy = ApplicationFacade.Instance.RetrieveProxy(Proxys.BATTLE_PROXY) as BattleProxy;
            var playerInfoProxy = ApplicationFacade.Instance.RetrieveProxy(Proxys.PLAYERINFO) as PlayerInfoProxy;
            areaItem.selectCard = null;
            //碰杠牌排序
            Vector3 pengGangPos = new Vector3(0.35f,0,0); // Vector3.zero;
            GameObject lastPengGangCard = null;
            int covertIndex = -1;//需要盖住的牌面序号
            var selfInfoVO = battleProxy.playerIdInfoDic[playerInfoProxy.UserInfo.UserID];
            for (int i = 0; i < areaItem.pengGangCards.Count; i++)
            {
                if (i > 0)
                {
                    pengGangPos += areaItem.pengGangGap * 1.2f;
                }
                if (areaItem.data.pengGangCards[i].targetUserId == areaItem.data.userId || areaItem.data.pengGangCards[i].targetUserId == 0)
                {
                    covertIndex = -1;
                }
                else if (battleProxy.playerIdInfoDic.ContainsKey(areaItem.data.pengGangCards[i].targetUserId))
                {
                    var targetPlayerInfoVO = battleProxy.playerIdInfoDic[areaItem.data.pengGangCards[i].targetUserId];
                    var targetIndex = (targetPlayerInfoVO.sit - areaItem.data.sit + GlobalData.SIT_NUM) % GlobalData.SIT_NUM;
                    covertIndex = GlobalData.SIT_NUM - targetIndex;
                }

                for (int j = 0; j < areaItem.pengGangCards[i].Count; j++)
                {
                    if (j > 0)
                    {
                        pengGangPos += areaItem.pengGangGap;
                    }
                    areaItem.pengGangCards[i][j].transform.localScale = Vector3.one;
                    if (covertIndex == j + 1 || covertIndex == -1)
                    {
                        areaItem.pengGangCards[i][j].transform.localEulerAngles = new Vector3(180, 0, 0);
                    }
                    else
                    {
                        var sitIndex = (areaItem.data.sit - selfInfoVO.sit + GlobalData.SIT_NUM) % GlobalData.SIT_NUM;
                        if (sitIndex == 2)//顶部
                        {
                            areaItem.pengGangCards[i][j].transform.localEulerAngles = new Vector3(0, -180, 0);
                        }
                        else
                        {
                            areaItem.pengGangCards[i][j].transform.localEulerAngles = Vector3.zero;
                        }

                    }

                    //areaItem.pengGangCards[i][j].layer = GlobalData.RIGHTHAND_CARDS;
                    if (areaItem.dir == AreaDir.RIGHT)
                    {
                        areaItem.pengGangCards[i][j].layer = GlobalData.RIGHTHAND_CARDS;
                    }
                    else
                    {
                        if (areaItem.data.userId == playerInfoProxy.UserInfo.UserID)
                        {
                            areaItem.pengGangCards[i][j].layer = GlobalData.SELF_HAND_CARDS;
                        }
                        else
                        {
                            areaItem.pengGangCards[i][j].layer = GlobalData.OTHER_CARDS;
                        }
                        
                    }

                    areaItem.pengGangCards[i][j].transform.localPosition = pengGangPos;
                    lastPengGangCard = areaItem.pengGangCards[i][j];
                }
            }
            //手中的牌排序
            Vector3 handPos = Vector3.zero;
            if (lastPengGangCard != null)
            {
                Camera cam;
                if (areaItem.data.userId == playerInfoProxy.UserInfo.UserID)
                {
                    cam = areaItem.myselfCamera;
                }
                else
                {
                    cam = Camera.main;
                }
                Vector3 pengGangScreenPos = cam.WorldToScreenPoint(lastPengGangCard.transform.position);
                Vector3 handScreenPos = cam.WorldToScreenPoint(areaItem.firstCard.position);
                pengGangScreenPos.z = handScreenPos.z;
                Vector3 pengGangWorldPos = cam.ScreenToWorldPoint(pengGangScreenPos);
                handPos = areaItem.handCardContainer.InverseTransformPoint(pengGangWorldPos);
                handPos += areaItem.handCardGap;
                handPos.y = 0;
                handPos.z = 0;
            }
            for (int i = 0; i < areaItem.handCards.Count; i++)
            {
                areaItem.handCards[i].transform.localScale = Vector3.one;
                areaItem.handCards[i].transform.localEulerAngles = Vector3.zero;
                areaItem.handCards[i].transform.localPosition = handPos;
                if (areaItem.data.userId == playerInfoProxy.UserInfo.UserID)
                {
                    areaItem.handCards[i].layer = GlobalData.SELF_HAND_CARDS;
                }
                else
                {
                    //areaItem.handCards[i].layer = GlobalData.OTHER_CARDS;
                    if (areaItem.dir == AreaDir.RIGHT)
                    {
                        areaItem.handCards[i].layer = GlobalData.RIGHTHAND_CARDS;
                    }
                    else
                        areaItem.handCards[i].layer = GlobalData.OTHER_CARDS;
                }
                if (i + 1 < areaItem.handCards.Count)
                {
                    handPos += areaItem.handCardGap;
                }
                else
                {
                    handPos += areaItem.getHandCardGap;
                }
            }
            //摸到的牌
            if (areaItem.getCard != null)
            {
                areaItem.getCard.transform.localScale = Vector3.one;
                areaItem.getCard.transform.localEulerAngles = Vector3.zero;
                areaItem.getCard.transform.localPosition = handPos;
                if (areaItem.data.userId == playerInfoProxy.UserInfo.UserID)
                {
                    areaItem.getCard.layer = GlobalData.SELF_HAND_CARDS;
                }
                else
                {
                    //areaItem.getCard.layer = GlobalData.OTHER_CARDS;
                    if (areaItem.dir == AreaDir.RIGHT)
                    {
                        areaItem.getCard.layer = GlobalData.RIGHTHAND_CARDS;
                    }
                    else
                        areaItem.getCard.layer = GlobalData.OTHER_CARDS;
                }
            }
        }

        /// <summary>
        /// 重排已出的牌
        /// </summary>
        public static void ResortPutCard(BattleAreaItem areaItem)
        {
            for (int i = 0; i < areaItem.putCards.Count; i++)
            {
                var anglePosition = GetPutCardPosition(areaItem, i);
                areaItem.putCards[i].transform.localScale = Vector3.one;
                areaItem.putCards[i].transform.localEulerAngles = anglePosition[0];
                areaItem.putCards[i].transform.localPosition = anglePosition[1];
                //areaItem.putCards[i].layer = GlobalData.OTHER_CARDS;
                if (areaItem.dir == AreaDir.RIGHT)
                {
                    areaItem.putCards[i].layer = GlobalData.RIGHTHAND_CARDS;
                }
                else
                    areaItem.putCards[i].layer = GlobalData.OTHER_CARDS;
            }
        }

        /// <summary>
        /// 获取当前牌的角度和坐标
        /// </summary>
        /// <param name="areaItem"></param>
        /// <param name="cardIndex"></param>
        /// <returns></returns>
        public static List<Vector3> GetPutCardPosition(BattleAreaItem areaItem, int cardIndex)
        {
            var anglePositionArr = new List<Vector3>();
            var battleProxy = ApplicationFacade.Instance.RetrieveProxy(Proxys.BATTLE_PROXY) as BattleProxy;
            var playerInfoProxy = ApplicationFacade.Instance.RetrieveProxy(Proxys.PLAYERINFO) as PlayerInfoProxy;
            var selfInfoVO = battleProxy.playerIdInfoDic[playerInfoProxy.UserInfo.UserID];
            int column = cardIndex % areaItem.putCardHNum;
            int row = cardIndex / areaItem.putCardHNum;
            var sitIndex = (areaItem.data.sit - selfInfoVO.sit + GlobalData.SIT_NUM) % GlobalData.SIT_NUM;
            if (sitIndex == 2)//顶部
            {
                anglePositionArr.Add(new Vector3(0, -180, 0));
            }
            else
            {
                anglePositionArr.Add(Vector3.zero);
            }
            anglePositionArr.Add(column * areaItem.putCardHGap + row * areaItem.putCardVGap);
            return anglePositionArr;
        }

        /// <summary>
        /// 牌面排序
        /// </summary>
        public static int CompareCard(GameObject card1, GameObject card2)
        {
            var cardValue1 = GetMeshCardValue(card1);
            var cardValue2 = GetMeshCardValue(card2);

            if (cardValue1 < cardValue2)
            {
                return -1;
            }
            else if (cardValue1 > cardValue2)
            {
                return 1;
            }
            else
            {
                int cardIndex1 = int.Parse(card1.name.Replace("HandCard", ""));
                int cardIndex2 = int.Parse(card2.name.Replace("HandCard", ""));
                return cardIndex1 < cardIndex2 ? -1 : 1;
            }
        }

        /// <summary>
        /// 初始化所有牌面
        /// </summary>
        public static void InitPlayerCards(BattleAreaItem areaItem)
        {
            var battleProxy = ApplicationFacade.Instance.RetrieveProxy(Proxys.BATTLE_PROXY) as BattleProxy;
            var playerInfoProxy = ApplicationFacade.Instance.RetrieveProxy(Proxys.PLAYERINFO) as PlayerInfoProxy;
            //恢复碰杠的牌
            Vector3 pengGangPos = Vector3.zero;
            GameObject lastPengGangCard = null;
            int covertIndex = -1;//需要盖住的牌面序号
            var selfInfoVO = battleProxy.playerIdInfoDic[playerInfoProxy.UserInfo.UserID];
            for (int i = 0; i < areaItem.data.pengGangCards.Count; i++)
            {
                if (i > 0)
                {
                    pengGangPos += areaItem.pengGangGap * 1.2f;
                }
                if (areaItem.data.pengGangCards[i].targetUserId == areaItem.data.userId || areaItem.data.pengGangCards[i].targetUserId == 0)
                {
                    covertIndex = -1;
                }
                else
                {
                    var targetPlayerInfoVO = battleProxy.playerIdInfoDic[areaItem.data.pengGangCards[i].targetUserId];
                    var targetIndex = (targetPlayerInfoVO.sit - areaItem.data.sit + GlobalData.SIT_NUM) % GlobalData.SIT_NUM;
                    covertIndex = GlobalData.SIT_NUM - targetIndex;
                }

                var cards = new List<GameObject>();
                for (int j = 0; j < areaItem.data.pengGangCards[i].pengGangCards.Count; j++)
                {
                    var card = ResourcesMgr.Instance.GetFromPool(areaItem.data.pengGangCards[i].pengGangCards[j]);
                    if (j > 0)
                    {
                        pengGangPos += areaItem.pengGangGap;
                    }
                    card.transform.SetParent(areaItem.pengGangCardContainer);
                    card.transform.localScale = Vector3.one;
                    if (covertIndex == j || covertIndex == -1)
                    {
                        card.transform.localEulerAngles = new Vector3(180, 0, 0);
                    }
                    else
                    {
                        card.transform.localEulerAngles = Vector3.zero;
                    }
                    card.transform.localPosition = pengGangPos;

                    //card.layer = GlobalData.OTHER_CARDS;

                    if (areaItem.dir == AreaDir.RIGHT)
                    {
                        card.layer = GlobalData.RIGHTHAND_CARDS;
                    }
                    else
                        card.layer = GlobalData.OTHER_CARDS;

                    lastPengGangCard = card;
                    cards.Add(card);
                }
                areaItem.pengGangCards.Add(cards);
            }
            //恢复手中的牌
            Vector3 handPos = Vector3.zero;
            if (lastPengGangCard != null)
            {
                Vector3 pengGangScreenPos = Camera.main.WorldToScreenPoint(lastPengGangCard.transform.position);
                Vector3 handScreenPos = Camera.main.WorldToScreenPoint(areaItem.firstCard.position);
                pengGangScreenPos.z = handScreenPos.z;
                Vector3 pengGangWorldPos = Camera.main.ScreenToWorldPoint(pengGangScreenPos);
                handPos = areaItem.handCardContainer.InverseTransformPoint(pengGangWorldPos);
                handPos += areaItem.handCardGap;
                handPos.y = 0;
                handPos.z = 0;
            }
            for (int i = 0; i < areaItem.data.handCards.Count; i++)
            {
                var card = ResourcesMgr.Instance.GetFromPool(areaItem.data.handCards[i]);
                card.transform.SetParent(areaItem.handCardContainer);
                card.transform.localScale = Vector3.one;
                card.transform.localEulerAngles = Vector3.zero;
                card.transform.localPosition = handPos;
                if (areaItem.data.userId == playerInfoProxy.UserInfo.UserID)
                {
                    card.layer = GlobalData.SELF_HAND_CARDS;
                }
                else
                {
                    //card.layer = GlobalData.OTHER_CARDS;
                    if (areaItem.dir == AreaDir.RIGHT)
                    {
                        card.layer = GlobalData.RIGHTHAND_CARDS;
                    }
                    else
                        card.layer = GlobalData.OTHER_CARDS;
                }
                if (i + 1 < areaItem.data.handCards.Count)
                {
                    handPos += areaItem.handCardGap;
                }
                else
                {
                    handPos += areaItem.getHandCardGap;
                }
                areaItem.handCards.Add(card);
            }
            //恢复摸到的牌
            if (areaItem.data.getCard > 0)
            {
                var card = ResourcesMgr.Instance.GetFromPool(areaItem.data.getCard);
                card.transform.SetParent(areaItem.handCardContainer);
                card.transform.localScale = Vector3.one;
                card.transform.localEulerAngles = Vector3.zero;
                card.transform.localPosition = handPos;
                areaItem.getCard = card;
                if (areaItem.data.userId == playerInfoProxy.UserInfo.UserID)
                {
                    areaItem.getCard.layer = GlobalData.SELF_HAND_CARDS;
                }
                else
                {
                    //areaItem.getCard.layer = GlobalData.OTHER_CARDS;
                    if (areaItem.dir == AreaDir.RIGHT)
                    {
                        areaItem.getCard.layer = GlobalData.RIGHTHAND_CARDS;
                    }
                    else
                        areaItem.getCard.layer = GlobalData.OTHER_CARDS;
                }
            }
            //恢复已发的牌
            Vector3 putPos = Vector3.zero;
            for (int i = 0; i < areaItem.data.putCards.Count; i++)
            {
                var card = ResourcesMgr.Instance.GetFromPool(areaItem.data.putCards[i]);
                int column = i % areaItem.putCardHNum;
                int row = i / areaItem.putCardHNum;
                card.transform.SetParent(areaItem.putCardContainer);
                card.transform.localScale = Vector3.one;
                var sitIndex = (areaItem.data.sit - selfInfoVO.sit + GlobalData.SIT_NUM) % GlobalData.SIT_NUM;
                if (sitIndex == 2)//顶部
                {
                    card.transform.localEulerAngles = new Vector3(0, -180, 0);
                }
                else
                {
                    card.transform.localEulerAngles = Vector3.zero;
                }
                card.transform.localPosition = putPos + column * areaItem.putCardHGap + row * areaItem.putCardVGap;
                
                if (areaItem.dir == AreaDir.RIGHT)
                {
                    card.layer = GlobalData.RIGHTHAND_CARDS;
                }
                else
                    card.layer = GlobalData.OTHER_CARDS;

                //card.layer = GlobalData.OTHER_CARDS;
                areaItem.putCards.Add(card);
            }
        }

        /// <summary>
        /// 获取当前牌内能吃的组合数组
        /// </summary>
        /// <param name="card"></param>
        /// <returns></returns>
        public static List<List<int>> GetCanChiArr(int card)
        {
            var result = new List<List<int>>();
            var battleProxy = ApplicationFacade.Instance.RetrieveProxy(Proxys.BATTLE_PROXY) as BattleProxy;
            var playerInfoProxy = ApplicationFacade.Instance.RetrieveProxy(Proxys.PLAYERINFO) as PlayerInfoProxy;
            var handCards = battleProxy.playerIdInfoDic[playerInfoProxy.UserInfo.UserID].handCards;

            int[] temp = { card + 1, card + 2, card - 1,  card + 1, card - 2, card - 1 };
            bool isContainAll = true;

            int count = temp.Length / 2;
            int index = 0;
            List<int> canSelectCard;
            for (int i = 0; i < count; i++)
            {
                isContainAll = true;
                canSelectCard = new List<int>();
                for (int j = 0; j < 2; j++)
                {
                    index = 2 * i + j;
                    canSelectCard.Add(temp[index]);
                    if (!handCards.Contains(temp[index]))
                    {
                        isContainAll = false;
                        break;
                    }
                }
                if (isContainAll)
                {
                    canSelectCard.Remove(card);
                    canSelectCard.Sort();
                    result.Add(canSelectCard);
                }
            }

            return result;
        }
    }
}
